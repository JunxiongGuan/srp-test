#!/bin/bash
#
# Copyright (c) 2016 Western Digital Corporation or its affiliates
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc.

vdev_path=(/dev/ram0 /dev/ram1)
scsi_serial=(ramdisk1 ramdisk2)
mountpoint=("$PWD/mnt1" "$PWD/mnt2")
ramdisk_size=$((1<<30)) # 1 GiB
options=()
debug=
filesystem_type=ext4
target_framework=lio
tests=()

usage() {
    echo "Usage: $1 [-d] [-f <filesystem type>] [-s] [-t <test>]*"
    exit 1
}

parse_cmdline() {
    while [ "${1#-}" != "$1" ]; do
	case "${1#-}" in
	    d) options+=($1);    debug=1;;
	    f) options+=($1 $2); filesystem_type=$2; shift;;
	    s) options+=($1);    target_framework=scst;;
	    t) options+=($1 $2); tests+=($2); shift;;
	    *) usage "$(dirname "$0")";;
	esac
	shift
    done

    [ $# = 0 ] || usage "$(dirname "$0")"
}

# Make the SRP initiator driver log in to each SRP target port.
srp_log_in() {
    local add_param=$1 d guid ibdev port

    for d in /dev/infiniband/umad*; do
	sysfsdir=/sys/class/infiniband_mad/$(basename "$d")
	ibdev=$(<"$sysfsdir/ibdev")
	port=$(<"$sysfsdir/port")
	guid=$(<"/sys/class/infiniband/$ibdev/ports/$port/gids/0")
	guid=${guid//:}
	ibsrpdm -c -d "$d" |
	    grep "dgid=$guid" |
	    while read -r line; do
		for p in /sys/class/infiniband_srp/*; do
		    [ -e "$p" ] || continue
		    {
			echo "$line,$add_param" >"$p/add_target"
		    } 2>/dev/null
		done
	    done
    done
}

# Tell the SRP initiator driver to log out.
srp_log_out() {
    local p

    if [ -e /sys/class/srp_remote_ports ]; then
	for p in /sys/class/srp_remote_ports/*; do
	    [ -e "$p" ] && echo 1 >"$p/delete" &
	done
    fi
    wait
}

remove_srp_mpath_devs() {
    (
	cd /sys/class/scsi_host &&
	    for p in /sys/class/srp_remote_ports/*; do
		[ -e "$p" ] || continue
		h="${p##*/}"; h="${h#port-}"; h="${h%:1}"
		for d in /sys/class/scsi_device/${h}:*/device/block/*; do
		    [ -e "$d" ] || continue
		    s=$(dirname "$(dirname "$(dirname "$d")")")
		    b=$(basename "$d")
		    for h in /sys/class/block/$b/holders/*; do
			[ -e "$h" ] || continue
			dm=/dev/$(basename "$h")
			echo -n "SRP LUN $s / $b: removing $dm: "
			dmsetup remove "$dm" && echo "done"
		    done
		done
	    done
    )
    # Find all multipaths with one or more deleted devices and remove these
    dmsetup table | while read -r mpdev fs ls type def; do
	echo "$fs $ls" >/dev/null
	if [ "$type" = multipath ]; then
	    for d in $def; do
		if [ "${d/://}" != "$d" ]; then
		    { grep -qw "$d" /sys/class/block/*/dev ||
			    echo "${mpdev%:}"; } 2>/dev/null
		fi
	    done
	fi
    done |
	sort -u |
	while read -r mpdev; do
	    mpdev="/dev/mapper/$mpdev"
	    echo -n "removing $mpdev: "
	    dmsetup message "$mpdev" 0 fail_if_no_path 2>/dev/null
	    for ((i=10;i>0;i--)); do
		if [ ! -e "$mpdev" ] ||
		       dmsetup remove "$mpdev" >/dev/null 2>&1; then
		    echo "done"
		    break
		fi
		sleep .1
	    done
	    [ $i = 0 ] && echo "failed"
	done
    return 0
}

unload_module() {
    local m=$1

    if [ -e "/sys/module/$m" ]; then
	modprobe -r "$m"
    fi
}

# Load the SRP initiator driver with kernel module parameters $1..$n.
start_srp() {
    modprobe scsi_transport_srp
    modprobe ib_srp "$@" || return $?
}

# Unload the SRP initiator driver.
stop_srp() {
    srp_log_out
    remove_srp_mpath_devs || return $?
    for ((i=20;i>=0;i--)); do
	unload_module ib_srp >/dev/null 2>&1 && break
	sleep .1
    done
    if [ -e /sys/module/ib_srp ]; then
	echo "Error: unloading kernel module ib_srp failed"
	return 1
    fi
    unload_module scsi_transport_srp || return $?
    echo "Unloaded the ib_srp kernel module"
}

# Load the configfs kernel module and mount it.
mount_configfs() {
    if [ ! -e /sys/module/configfs ]; then
	modprobe configfs || return $?
    fi
    if ! mount | grep -qw configfs; then
	mount -t configfs none /sys/kernel/config || return $?
    fi
}

# Associate the LIO device with name $1/$2 with file $3 and SCSI serial $4.
configure_lio_vdev() {
    local dirname=$1 vdev=$2 path=$3 serial=$4

    (
	cd /sys/kernel/config/target/core &&
	    mkdir "$dirname" &&
	    cd "$dirname" &&
	    mkdir "$vdev" &&
	    cd "$vdev" &&
	    if [ -b "$path" ]; then
		echo "udev_path=$path," >control
	    else
		size=$(stat -c %s "${path}") &&
		    [ "$size" -gt 0 ] &&
		    echo "fd_dev_name=$path,fd_dev_size=$size," >control
	    fi &&
	    echo "${serial}" >wwn/vpd_unit_serial &&
	    echo 1 > enable
    )
}

lio_scsi_mpath_id() {
    local i=$1 hs

    hs=$(echo -n "${scsi_serial[i]}" | od -v -tx1 -w99 |
		{ read -r offset bytes;
		  echo "${bytes// }";
		  echo "$offset" > /dev/null
		})
    while [ ${#hs} -lt 25 ]; do
	hs="${hs}0"
    done
    # See also spc_emulate_evpd_83() in drivers/target/target_core_spc.c.
    echo "36001405$hs"
}

scst_scsi_mpath_id() {
    local i=$1

    echo "2$(echo -n "${scsi_serial[$i]}" | od -tx1 -N8 | sed 's/^[0-9]*[[:blank:]]*//;s/[[:blank:]]//g')"
}

scsi_mpath_id() {
    case "$target_framework" in
	lio)  lio_scsi_mpath_id "$@";;
	scst) scst_scsi_mpath_id "$@";;
	*)    false;;
    esac || return $?
}

# Load LIO and configure the SRP target driver and LUNs
start_lio_srpt() {
    local b d hca i m p r rdma_port vdev

    rdma_port=()
    hca=($(sed 's/^/0x/;s/://g' /sys/devices/*/*/*/infiniband/*/ports/*/gids/0))
    rdma_port=($(sed 's/^fe8/0x000/;s/://g' /sys/devices/*/*/*/infiniband/*/ports/*/gids/0))
    mount_configfs || return $?
    modprobe target_core_mod || return $?
    modprobe target_core_iblock || return $?
    insmod "/lib/modules/$(uname -r)/kernel/drivers/infiniband/ulp/srpt/ib_srpt.ko" srp_max_req_size=4200 dyndbg=+pmf || return $?
    i=0
    for r in "${vdev_path[@]}"; do
	if [ -b "$r" ]; then
	    oflag=oflag=direct
	else
	    oflag=
	fi
	dd if=/dev/zero of="${r}" bs=1M count=$((ramdisk_size>>20)) ${oflag} >/dev/null 2>&1 || return $?
	mkdir -p "${mountpoint[i]}"
	((i++))
    done
    vdev=(iblock_0/vdev0 iblock_1/vdev1)
    for ((i=0; i < ${#vdev[@]}; i++)); do
	d="$(dirname "${vdev[i]}")"
	b="$(basename "${vdev[i]}")"
	hs=$(lio_scsi_mpath_id "$i")
	hs=${hs#36001405}
	configure_lio_vdev "$d" "$b" "${vdev_path[i]}" "$hs" ||
	    return $?
    done
    (
	cd /sys/kernel/config/target || exit $?
	mkdir srpt || exit $?
	cd srpt || exit $?
	for hca in "${hca[@]}"; do
	    mkdir "$hca" || exit $?
	    [ -e "$hca" ] || continue
	    #echo "$hca"
	    mkdir "$hca/$hca" || exit $?
	    i=0
	    for v in "${vdev[@]}"; do
		mkdir "$hca/$hca/lun/lun_$i" || exit $?
		(
		    cd "$hca/$hca/lun/lun_$i" &&
			ln -s "../../../../../core/$v"
		) || exit $?
		i=$((i+1))
	    done
	    for p in "${rdma_port[@]}"; do
		(
		    cd "$hca/$hca/acls" &&
			mkdir "${p}" &&
			cd "${p}" &&
			for ((i = 0; i < ${#vdev[@]}; i++)) do
			    (
				mkdir lun_$i &&
				    cd lun_$i &&
				    ln -s ../../../lun/lun_$i
			    ) || exit $?
			done
		) || exit $?
		echo 1 >"$hca/$hca/enable"
	    done
	done
    )
}

# Unload the LIO SRP target driver.
stop_lio_srpt() {
    local hca

    mount_configfs
    for e in /sys/kernel/config/target/srpt/$hca/$hca/enable; do
	if [ -e "$e" ]; then
	    echo 0 >"$e"
	fi
    done

    rm -f /sys/kernel/config/target/srpt/*/*/acls/*/*/* >&/dev/null
    rmdir /sys/kernel/config/target/srpt/*/*/acls/*/* >&/dev/null
    rmdir /sys/kernel/config/target/srpt/*/*/acls/* >&/dev/null
    rm -f /sys/kernel/config/target/srpt/*/*/lun/*/* >&/dev/null
    rmdir /sys/kernel/config/target/srpt/*/*/lun/* >&/dev/null
    rmdir /sys/kernel/config/target/srpt/*/* >&/dev/null
    rmdir /sys/kernel/config/target/srpt/* >&/dev/null
    rmdir /sys/kernel/config/target/srpt >&/dev/null

    unload_module ib_srpt || return $?

    rmdir /sys/kernel/config/target/core/*/* >&/dev/null
    rmdir /sys/kernel/config/target/core/* >&/dev/null

    for m in ib_srpt target_core_pscsi target_core_iblock target_core_file \
		     target_core_stgt target_core_user target_core_mod
    do
	unload_module $m || return $?
    done
}

# Associate the SCST device with name $2 with handler $1, file $3 and SCSI
# serial $4.
configure_scst_vdev() {
    local handler=$1 scst_dev=$2 path=$3 serial=$4

    (
	cd "/sys/kernel/scst_tgt/handlers/$handler" &&
	    echo "add_device $scst_dev filename=$path" >mgmt &&
	    cd "$scst_dev" &&
	    echo "$serial" >t10_dev_id
    )
}

# Load the SCST SRP target driver.
start_scst_srpt() {
    local b d hca i m p r vdev

    hca=($(cat /sys/devices/*/*/*/infiniband/*/ports/*/gids/0))

    modprobe scst_vdisk || return $?
    insmod "/lib/modules/$(uname -r)/extra/ib_srpt.ko" srp_max_req_size=4200 dyndbg=+pmf || return $?
    for r in "${vdev_path[@]}"; do
	if [ -b "$r" ]; then
	    oflag=oflag=direct
	else
	    oflag=
	fi
	dd if=/dev/zero of="${r}" bs=1M count=$((ramdisk_size>>20)) ${oflag} >/dev/null 2>&1 || return $?
	mkdir -p "${mountpoint[i]}"
	((i++))
    done
    (
	cd /sys/kernel/scst_tgt/handlers/vdisk_nullio &&
	    echo add_device dummy dummy=1 >mgmt
    ) || return $?
    vdev=(vdisk_blockio/vdev0 vdisk_blockio/vdev1)
    for ((i=0; i < ${#vdev[@]}; i++)); do
	d="$(dirname "${vdev[i]}")"
	b="$(basename "${vdev[i]}")"
	configure_scst_vdev "$d" "$b" "${vdev_path[i]}" "${scsi_serial[i]}" ||
	    return $?
    done
    (
	cd /sys/kernel/scst_tgt/targets/ib_srpt || exit $?
	for h in "${hca[@]}"; do
	    echo "add dummy 0" >"$h/luns/mgmt" || exit $?
	    (
		cd "$h/ini_groups" &&
		    echo "create all" >mgmt &&
		    cd all
	    ) || exit $?
	    i=0
	    for v in "${vdev[@]}"; do
		d="$(dirname "${vdev[i]}")"
		b="$(basename "${vdev[i]}")"
		echo "add $b $i" >"$h/ini_groups/all/luns/mgmt" || exit $?
		i=$((i+1))
	    done
	    echo "add $h" >"$h/ini_groups/all/initiators/mgmt" || exit $?
	    echo 1 >"$h/enabled" || exit $?
	done
    ) || return $?
}

# Unload the SCST SRP target driver.
stop_scst_srpt() {
    local rc=0 m

    for m in ib_srpt scst_vdisk scst; do
	unload_module "$m" || rc=$?
    done
    return $rc
}

# Load and configure the SRP target driver
start_srpt() {
    modprobe brd rd_nr=${#vdev_path[@]} rd_size=$((ramdisk_size>>10))
    case "$target_framework" in
	lio)  start_lio_srpt;;
	scst) start_scst_srpt;;
	*)    false;;
    esac || return $?
    echo "Configured SRP target driver"
}

# Unload the SRP target driver.
stop_srpt() {
    case "$target_framework" in
	lio)  stop_lio_srpt;;
	scst) stop_scst_srpt;;
	*)    false;;
    esac || return $?
    unload_module brd || return $?
    rm -f "${vdev_path[@]}"
    echo "Unloaded the ib_srpt kernel module"
}

# Look up the block device below the filesystem on which directory $1 exists.
block_dev_of_dir() {
    df "$1" | {
	read -r header
	echo "$header" >/dev/null
	read -r blockdev rest
	echo "$blockdev"
    }
}

create_filesystem() {
    local dev=$1

    case "$filesystem_type" in
	ext4)
	    mkfs.ext4 -F -O ^has_journal -q "$dev";;
	xfs)
	    mkfs.xfs -f -q "$dev";;
	*)
	    return 1;;
    esac
}

mount_and_check() {
    local dir last

    dir=$(for last; do :; done; echo "$last")
    mount "$@"
    if [ "$(block_dev_of_dir "$dir")" = "$(block_dev_of_dir "$(dirname "$dir")")" ]; then
	echo "Error: mount $* failed"
	return 1
    fi
}

unmount_and_check() {
    local m=$1

    umount "$m" >/dev/null 2>&1
    if [ "$(block_dev_of_dir "$m")" != "$(block_dev_of_dir "$(dirname "$m")")" ]; then
	echo "Error: unmounting $m failed"
	return 1
    fi
}

# Test whether fio supports command-line options "$@"
test_fio_opt() {
    ! fio --name=arg-test --filename=/dev/null "$@" 2>&1 |
	grep -q 'unrecognized option'
}

run_fio() {
    local opt args

    args=("$@")
    for opt in --exitall_on_error=1 --gtod_reduce=1; do
	if test_fio_opt "$opt"; then
	    args+=("$opt")
	fi
    done
    fio "${args[@]}"
}

# To suppress a shellcheck warning
[ -n "$debug" ]
